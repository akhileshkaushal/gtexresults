---
title: "Add title here."
author: "Sarah Urbut, Gao Wang, Peter Carbonetto and Matthew Stephens"
output: workflowr::wflow_html
---

Here we plot RMSE and ROC:

```{r knitr, message = FALSE, echo = FALSE}
knitr::opts_chunk$set(collapse = TRUE, fig.width = 8,
                      fig.height = 4,fig.align = "center",
                      comment = "#")
```

```{r}
colors <- c("#E69F00","#56B4E9","#009E73","#F0E442", "#0072B2","#D55E00",
             "#CC79A7")
data=readRDS("../output/simdata.rds")
t=data$tstat[1:20000,]
bhat=data$betahat[1:20000,]
sebetahat=data$sebetahat[1:20000,]
beta=data$beta[1:20000,]
v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
mash.means=
  read.table("../output/sharedashcutoffomega2jun15posterior.means.txt.gz")[,-1]
univariate.ash.pm=read.table("../output/univariate.ash.pm.txt.gz")
bma.pm=
  read.table("../output/noashsharedwithzerobmaallposterior.means.txt.gz")[,-1]
lfsr.mash=read.table("../output/sharedashcutoffomega2jun15lfsr.txt.gz")[,-1]
lfsr.bma=read.table("../output/noashsharedwithzerobmaalllfsr.txt.gz")[,-1]
lfsr.ash=read.table("../output/univariate.ash.lfsr.txt.gz")
```

And for all 20K:

```{r rmsesharedtwo}
sebetahat=data$sebetahat
sebetahat=sebetahat[1:20000,]
standard=sqrt(mean((beta[1:20000,]-bhat[1:20000,])^2))
sqrt(mean((beta[1:20000,]-mash.means[1:20000,]*sebetahat)^2))/standard
sqrt(mean((beta[1:20000,]-univariate.ash.pm[1:20000,]*sebetahat)^2))/standard
sqrt(mean((beta[1:20000,]-bma.pm[1:20000,]*sebetahat)^2))/standard
rmse.all.table=
  cbind(mash = sqrt(mean((beta[1:20000,] -
                    mash.means[1:20000,]*sebetahat)^2))/standard,
		"mash-bmalite"=sqrt(mean((beta[1:20000,]-
		bma.pm[1:20000,]*sebetahat)^2))/standard,
		ash=sqrt(mean((beta[1:20000,] -
		univariate.ash.pm[1:20000,]*sebetahat)^2))/standard) 
barplot(as.numeric(rmse.all.table),main="Shared, Structured Effects",
  ylab="relative error (RRMSE)",xlab="",col=colors[5:7],
  names=colnames(rmse.all.table),ylim=c(0,0.25),cex.main=1.5,
  cex.lab=1,cex.names=1,las=1)
```

```{r}
beta=as.matrix(beta[1:20000,])
lfsr.mash=as.matrix(lfsr.mash)
lfsr.ash=as.matrix(lfsr.ash)
lfsr.bma=as.matrix(lfsr.bma)
mash.means=as.matrix(mash.means)
ash.means=as.matrix(univariate.ash.pm)
bma.means=as.matrix(bma.pm)
```

Then, we compute the nominal lfsr (S) value, and we ask how many we
correctly and incorrectly sign at a given threshold.

```{r}
sign.test.mash=beta*mash.means
sign.test.ash=beta*ash.means
sign.test.bma=beta*bma.means
```

```{r roccurve1shared, fig.height=5,fig.width=5,echo=F,fig.show=T}
mash.power=NULL
ash.power=NULL
bma.power=NULL
mash.call.power=NULL
ash.call.power=NULL
bma.call.power=NULL
mash.fp=NULL
ash.fp=NULL
bma.fp=NULL

thresholds=seq(0.01,1,by=0.01)
for(s in 1:length(thresholds)){
thresh=thresholds[s]

# Sign power is the proportion of true effects correctly signed at a
# given threshold.
mash.power[s]=sum(sign.test.mash>0&lfsr.mash<=thresh)/sum(beta!=0)
ash.power[s]=sum(sign.test.ash>0&lfsr.ash<=thresh)/sum(beta!=0)
bma.power[s]=sum(sign.test.bma>0&lfsr.bma<=thresh)/sum(beta!=0)

# False positives is the proportion of null effects called at a given
# threshold.

mash.fp[s]=sum(beta==0&lfsr.mash<=thresh)/sum(beta==0)
ash.fp[s]=sum(beta==0&lfsr.ash<=thresh)/sum(beta==0)
bma.fp[s]=sum(beta==0&lfsr.bma<=thresh)/sum(beta==0)
}

plot(mash.fp,mash.power,cex=0.5,pch=1,xlim=c(0,0.2),lty=1,lwd=3,
     ylim=c(0,1),col=colors[5],ylab="True Positive Rate",
     xlab="False Positive Rate",type="l",main="Shared, Structured")
lines(bma.fp,bma.power,cex=0.5,pch=1,ylim=c(0,1),col=colors[6],lty=2,lwd=3)
lines(ash.fp,ash.power,cex=0.5,pch=1,ylim=c(0,1),col=colors[7],lty=3,lwd=3)
legend("bottomright",legend = c("mash","mash-bmalite","ash"),
       col=colors[5:7],lty=c(1,2,3))
```

Now, let's do this for the independendent (shared unstructured) case:

```{r, echo=F}
data = readRDS("../output/independentsimesd05.rds")
t=data$tstat[1:20000,]
bhat=data$betahat[1:20000,]
sebetahat=data$sebetahat[1:20000,]
beta=data$beta[1:20000,]
v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
mash.means = read.table("../output/indsim05sdposterior.means.txt.gz")[,-1]
univariate.ash.pm = read.table("../output/univariate.ash.pmindesd.txt.gz")
bma.pm=read.table("../output/bmaonlybetasd5posterior.means.txt.gz")[,-1]
lfsr.mash=read.table("../output/indsim05sdlfsr.txt.gz")[,-1]
lfsr.bma=read.table("../output/bmaonlybetasd5lfsr.txt.gz")[,-1]
lfsr.ash=read.table("../output/univariate.ashind.lfsresd.txt.gz")
```

And for all 20K:

```{r}
sebetahat=data$sebetahat
sebetahat=sebetahat[1:20000,]
standard=sqrt(mean((beta[1:20000,]-bhat[1:20000,])^2))
sqrt(mean((beta[1:20000,]-mash.means[1:20000,]*sebetahat)^2))/standard
sqrt(mean((beta[1:20000,]-univariate.ash.pm[1:20000,]*sebetahat)^2))/standard
sqrt(mean((beta[1:20000,]-bma.pm[1:20000,]*sebetahat)^2))/standard
rmse.all.table = cbind(mash=sqrt(mean((beta[1:20000,] -
  mash.means[1:20000,]*sebetahat)^2))/standard,
  "mash-bmalite" = sqrt(mean((beta[1:20000,] -
  bma.pm[1:20000,]*sebetahat)^2))/standard,
  ash=sqrt(mean((beta[1:20000,] -
  univariate.ash.pm[1:20000,]*sebetahat)^2))/standard) 
barplot(as.numeric(rmse.all.table),main="Shared, Unstructured Effects",
        ylab="relative error (RRMSE)",xlab="",col=colors[5:7],
        names=colnames(rmse.all.table),ylim=c(0,0.25),cex.main=1.5,
		cex.lab=1,cex.names=1,las=1)
```

```{r}
beta=as.matrix(beta[1:20000,])
lfsr.mash=as.matrix(lfsr.mash)
lfsr.ash=as.matrix(lfsr.ash)
lfsr.bma=as.matrix(lfsr.bma)
mash.means=as.matrix(mash.means)
ash.means=as.matrix(univariate.ash.pm)
bma.means=as.matrix(bma.pm)
```

```{r}
sign.test.mash=beta*mash.means
sign.test.ash=beta*ash.means
sign.test.bma=beta*bma.means
```

```{r roccurve1unstrcutured}
mash.power=NULL
ash.power=NULL
bma.power=NULL
mash.call.power=NULL
ash.call.power=NULL
bma.call.power=NULL
mash.fp=NULL
ash.fp=NULL
bma.fp=NULL
thresholds=seq(0.01,1,by=0.01)
for(s in 1:length(thresholds)){
thresh=thresholds[s]

#sign power is the proportion of true effects correctly signed at a
# given threshold
mash.power[s]=sum(sign.test.mash>0&lfsr.mash<=thresh)/sum(beta!=0)
ash.power[s]=sum(sign.test.ash>0&lfsr.ash<=thresh)/sum(beta!=0)
bma.power[s]=sum(sign.test.bma>0&lfsr.bma<=thresh)/sum(beta!=0)

# false positives is the proportion of null effects called at a given
# threshold
mash.fp[s]=sum(beta==0&lfsr.mash<=thresh)/sum(beta==0)
ash.fp[s]=sum(beta==0&lfsr.ash<=thresh)/sum(beta==0)
bma.fp[s]=sum(beta==0&lfsr.bma<=thresh)/sum(beta==0)
}

plot(mash.fp,mash.power,cex=0.5,pch=1,xlim=c(0,0.2),lty=1,lwd=3,ylim=c(0,1),
     col=colors[5],ylab="True Positive Rate",xlab="False Positive Rate",
     type="l",main="Shared, Unstructured")
lines(bma.fp,bma.power,cex=0.5,pch=1,ylim=c(0,1),col=colors[6],lty=2,lwd=3)
lines(ash.fp,ash.power,cex=0.5,pch=1,ylim=c(0,1),col=colors[7],lty=3,lwd=3)
legend("bottomright",legend = c("mash","mash-bmalite","ash"),
       col=colors[5:7],lty=c(1,2,3))
```

## Now let's do on a per gene basis:

```{r}
data=readRDS("../output/simdata.rds")
t=data$tstat
bhat=data$betahat
sebetahat=data$sebetahat
beta=data$beta
v.j=matrix(rep(1,ncol(t)*nrow(t)),ncol=ncol(t),nrow=nrow(t))
log.bf=read.table("~/Downloads/logBFTABLEapril.txt")
bf.mash=log.bf[,"bf.mash"]
bf.bma=log.bf[,"bf.bma"]
bf.mash.independent=log.bf[,"bf.mash.independent"]
bf.bma.independent=log.bf[,"bf.bma.independent"]

eskin=read.table("~/Downloads/44binary.txt",sep = "\t",header = F,skip=1)
NAMES <- strsplit(readLines(file("~/Dropbox/sharedtest","rt"), 1), "\t")[[1]]
colnames(eskin)[1:16]=NAMES[1:16]
lfsr.mash=read.table("shared/sharedashcutoffomega2jun15lfsr.txt")[,-1]
lfsr.bma=read.table("shared/noashsharedwithzerobmaalllfsr.txt")[,-1]
lfsr.ash=read.table("shared/univariate.ash.lfsr.txt")

ash.min=apply(lfsr.ash,1,min)
p.FE=eskin[,"PVALUE_FE"]
p.RE=eskin[,"PVALUE_RE"]
p.RE2=eskin[,"PVALUE_RE2"]
p.BE=eskin[,"PVALUE_BE"]

FE.TP=RE.TP=RE2.TP=ASH.TP=BE.TP=NULL
FE.FP=RE.FP=RE2.FP=ASH.FP=BE.FP=NULL

thresh=seq(0,1,by=0.0001)
for(s in 1:length(thresh)){
  d=thresh[s]
  FE.TP[s]=mean(p.FE[1:400]<d)
  RE.TP[s]=mean(p.RE[1:400]<d)
  RE2.TP[s]=mean(p.RE2[1:400]<d)
  BE.TP[s]=mean(p.BE[1:400]<d)
  ASH.TP[s]=mean(ash.min[1:400]<d)
  FE.FP[s]=mean(p.FE[401:20000]<d)
  RE.FP[s]=mean(p.RE[401:20000]<d)
  RE2.FP[s]=mean(p.RE2[401:20000]<d)
  BE.FP[s]=mean(p.BE[401:20000]<d)
  ASH.FP[s]=mean(ash.min[401:20000]<d)
}
```

Now, let's compare to BF:

```{r bfshared, fig.height=5,fig.width=5,echo=F,fig.show=T }
mash.tp=NULL
mash.fp=NULL
bma.tp=NULL
bma.fp=NULL
ind=seq(1:length(bf.mash))
thresholds=seq(-2,5,by=0.01)

for(t in 1:length(thresholds)){

thresh=thresholds[t]
mash.tp[t]=sum(bf.mash[1:400]>thresh)/400
mash.fp[t]=sum(bf.mash[401:20000]>thresh)/(20000-400)
bma.tp[t]=sum(bf.bma[1:400]>thresh)/400
bma.fp[t]=sum(bf.bma[401:20000]>thresh)/(20000-400)
}


plot(FE.FP,FE.TP,ylim=c(0,1),cex=0.5,xlim=c(0,0.2),
     lwd=3,ylab="True Positive Rate",
     xlab="False Positive Rate",lty=4,
	 main="Shared, Structured",col=colors[3],type="l")

lines(RE2.FP,RE2.TP,col=colors[1],lty=5,lwd=3)
lines(mash.fp,mash.tp,col=colors[5],lty=1,lwd=3)
lines(bma.fp,bma.tp,col=colors[6],lty=2,lwd=3)
lines(ASH.FP,ASH.TP,col=colors[7],lty=3,lwd=3)
lines(BE.FP,BE.TP,col="pink",lty=6,lwd=3)

legend("bottomright",legend = c("mash","mash-bmalite","ash",
       "metasoft.RE2","metasoft.FE","metasoft.BE"),
       col=c(colors[5],colors[6],colors[7],colors[1],colors[3],"pink"),
	   lty=c(1,2,3,5,4,6))
```

## Now, let's do the per gene basis for the shared unstrcutred case:

```{r}
data=readRDS("../output/independentsimesd05.rds")
t=data$tstat[1:20000,]
bhat=data$betahat[1:20000,]
sebetahat=data$sebetahat[1:20000,]
v.j=sebetahat/sebetahat
lfsr.mash=read.table("../output/indsim05sdlfsr.txt.gz")
lfsr.bma=read.table("../output/bmaonlybetasd5lfsr.txt.gz")[,-1]
lfsr.ash=read.table("../output/univariate.ashind.lfsresd.txt.gz")
lfsr.ash=read.table("../output/univariate.ashind.lfsresd.txt.gz")
# NAMES <- strsplit(readLines(file("~/Dropbox/independentsiminputdata","rt"),
# 1), "\t")[[1]]
eskin=read.table("~/Downloads/independenttest.txt",sep = "\t",header = F,skip=1)
# colnames(eskin)[1:16]=NAMES[1:16]

mash.min=apply(lfsr.mash,1,min)
bma.min=apply(lfsr.bma,1,min)
ash.min=apply(lfsr.ash,1,min)
p.FE=eskin[,"PVALUE_FE"]
p.RE=eskin[,"PVALUE_RE"]
p.RE2=eskin[,"PVALUE_RE2"]
p.BE=eskin[,"PVALUE_BE"]

FE.TP=RE.TP=RE2.TP=ASH.TP=BE.TP=NULL
FE.FP=RE.FP=RE2.FP=ASH.FP=BE.FP=NULL

thresh=seq(0,1,by=0.0001)
for(s in 1:length(thresh)){
  d=thresh[s]
  FE.TP[s]=mean(p.FE[1:400]<d)
  RE.TP[s]=mean(p.RE[1:400]<d)
  RE2.TP[s]=mean(p.RE2[1:400]<d)
  BE.TP[s]=mean(p.BE[1:400]<d)
  ASH.TP[s]=mean(ash.min[1:400]<d)

  
  FE.FP[s]=mean(p.FE[401:20000]<d)
  RE.FP[s]=mean(p.RE[401:20000]<d)
  RE2.FP[s]=mean(p.RE2[401:20000]<d)
  BE.FP[s]=mean(p.BE[401:20000]<d)
  ASH.FP[s]=mean(ash.min[401:20000]<d)

  
}

```

Now let's do this with the Bayes Factor's ascertained from mash and bma:

```{r bfind, fig.height=5,fig.width=5,echo=F,fig.show=T}
mash.tp=NULL
mash.fp=NULL
bma.tp=NULL
bma.fp=NULL
ind=seq(1:length(bf.mash))
thresholds=seq(-2,2,by=0.01)
for(t in 1:length(thresholds)){
  thresh=thresholds[t]
  mash.tp[t]=sum(bf.mash.independent[1:400]>thresh)/400
  mash.fp[t]=sum(bf.mash.independent[401:20000]>thresh)/(20000-400)
  bma.tp[t]=sum(bf.bma.independent[1:400]>thresh)/400
  bma.fp[t]=sum(bf.bma.independent[401:20000]>thresh)/(20000-400)
}
plot(FE.FP,FE.TP,ylim=c(0,1),cex=0.5,xlim=c(0,0.2),lwd=3,
     ylab="True Positive Rate",xlab="False Positive Rate",lty=4,
     main="Shared, Unstructured",col=colors[3],type="l")
lines(RE2.FP,RE2.TP,col=colors[1],lty=5,lwd=3)
lines(mash.fp,mash.tp,col=colors[5],lty=1,lwd=3)
lines(bma.fp,bma.tp,col=colors[6],lty=2,lwd=3)
lines(ASH.FP,ASH.TP,col=colors[7],lty=3,lwd=3)
lines(BE.FP,BE.TP,col="pink",lty=6,lwd=3)
legend("bottomright",legend = c("mash","mash-bmalite","ash",
       "metasoft.RE2","metasoft.FE","metasoft.BE"),
       col=c(colors[5],colors[6],colors[7],colors[1],colors[3],"pink"),
	   lty=c(1,2,3,5,4,6))
```



